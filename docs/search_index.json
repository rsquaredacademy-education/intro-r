[
["index.html", "Introduction to R Preface Structure of the book Software information", " Introduction to R Aravind Hebbali Preface This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Structure of the book Software information The R session information when compiling this book is shown below: sessionInfo() ## R version 3.5.1 (2018-07-02) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 17134) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_India.1252 LC_CTYPE=English_India.1252 ## [3] LC_MONETARY=English_India.1252 LC_NUMERIC=C ## [5] LC_TIME=English_India.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_3.5.1 magrittr_1.5 bookdown_0.7 tools_3.5.1 ## [5] htmltools_0.3.6 rstudioapi_0.8 yaml_2.2.0 Rcpp_1.0.0 ## [9] stringi_1.2.4 rmarkdown_1.11 knitr_1.21 stringr_1.3.1 ## [13] xfun_0.4 digest_0.6.18 evaluate_0.12 "],
["about-the-author.html", "About the Author", " About the Author Aravind Hebbali is the founder of Rsquared Academy. He earned his Masters in Economics from Madras School of Economics. As an active R user, he has authored several R packages such as olsrr rfm descriptr blorr xplorerr In 2015, he founded Rsquared Academy, a free and open source education initiative with focus on data science and analytics. Apart from self paced online courses, Rsquared Academy offers customized learning modules for corporates and universities. You can find him on GitHub. "],
["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction "],
["installation.html", "Chapter 2 Installation 2.1 R 2.2 RStudio", " Chapter 2 Installation 2.1 R 2.2 RStudio "],
["variables.html", "Chapter 3 Variables 3.1 Introduction 3.2 What is a variable? 3.3 Creating Variables 3.4 Using Variables 3.5 Components of a Variable 3.6 Naming Conventions", " Chapter 3 Variables 3.1 Introduction In the previous post, we learnt to install RStudio. In this post, we will learn about variables and data types. You can skip this post, if you have prior experience in any other programming language. 3.2 What is a variable? variables are the fundamental elements of any programming language they are used to represent values that are likely to change they reference memory locations that store information/data Let us use a simple case study to understand variables. Suppose you are computing the area of a circle whose radius is 3. In R, you can do this straight away as shown below: 3.14 * 3 * 3 ## [1] 28.26 But you cannot reuse the radius or the area computed in any other analysis or computation. Let us see how variables can change the above scenario and help us in reusing values and computations. 3.3 Creating Variables A variable consists of 3 components: variable name assignment operator variable value We can store the value of the radius by creating a variable and assigning it the value. In this case, we create a variable called radius and assign it the value 3 using the assignment operator &lt;-. radius &lt;- 3 radius ## [1] 3 Now that we have learnt to create variables, let us see how we can use them for other computations. For our case study, we will use the radius variable to compute the area of a circle. 3.4 Using Variables We will create two variables, radius and pi, and use them to compute the area of a circle and store it in another variable area. # assign value 3 to variable radius radius &lt;- 3 # assign value 3.14 to variable pi pi &lt;- 3.14 # compute area of circle area &lt;- pi * radius * radius # call radius radius ## [1] 3 # call area area ## [1] 28.26 3.5 Components of a Variable 3.6 Naming Conventions Name must begin with a letter. Do not use numbers, dollar sign ($) or underscore (_). The name can contain numbers or underscore. Do not use dash (-) or period (.). Do not use the names of keywords and avoid using the names of built in functions. Variables are case sensitive; average and Average would be different variables. Use names that are descriptive. Generally, variable names should be nouns. If the name is made of more than one word, use underscore to separate the words. "],
["datatypes.html", "Chapter 4 Data Types 4.1 Introduction 4.2 Numeric 4.3 Integer 4.4 Character 4.5 Logical", " Chapter 4 Data Types 4.1 Introduction In this chapter, we will learn about the following data types: numeric/double integer character logical date/time 4.2 Numeric In R, numbers are represented by the data type numeric. We will first create a variable and assign it a value. Next we will learn a few methods of checking the type of the variable. # create two variables number1 &lt;- 3.5 number2 &lt;- 3 # check data type class(number1) ## [1] &quot;numeric&quot; class(number2) ## [1] &quot;numeric&quot; # check if data type is numeric is.numeric(number1) ## [1] TRUE is.numeric(number2) ## [1] TRUE If you carefully observe, integers are also treated as numeric/double. We will learn to create integers in a while. In the meanwhile, we have introduced two new funtions in the above example: class(): returns the class or type is.numeric(): tests whether the variable is of type numeric 4.3 Integer Unless specified otherwise, integers are treated as numeric or double. In this section, we will learn to create variables of the type integer and to convert other data types to integer. create a variable number1 and assign it the value 3 check the data type of number1 using class create a second variable number2 using as.integer and assign it the value 3 check the data type of number2 using class finally use is.integer to check the data type of both number1 and number2 # create a variable and assign it an integer value number1 &lt;- 3 # create another variable using as.integer number2 &lt;- as.integer(3) # check the data type class(number1) ## [1] &quot;numeric&quot; class(number2) ## [1] &quot;integer&quot; # use is.integer to check data type is.integer(number1) ## [1] FALSE is.integer(number2) ## [1] TRUE 4.4 Character Letters, words and group of words are represented by the data type character. All data of type character must be enclosed in single or double quotation marks. In fact any value enclosed in quotes will be treated as character. Let us create two variables to store the first and last name of a some random guy. # first name first_name &lt;- &quot;jovial&quot; # last name last_name &lt;- &#39;mann&#39; # check data type class(first_name) ## [1] &quot;character&quot; class(last_name) ## [1] &quot;character&quot; # use is.charactert to check data type is.character(first_name) ## [1] TRUE is.character(last_name) ## [1] TRUE You can coerce any data type to character using as.character(). # create variable of different data types age &lt;- as.integer(30) # integer score &lt;- 9.8 # numeric/double opt_course &lt;- TRUE # logical today &lt;- Sys.time() # date time as.character(age) ## [1] &quot;30&quot; as.character(score) ## [1] &quot;9.8&quot; as.character(opt_course) ## [1] &quot;TRUE&quot; as.character(today) ## [1] &quot;2019-02-12 18:44:34&quot; 4.5 Logical Logical data types take only 2 values. Either TRUE or FALSE. Sich data types are created when we compare two objects in R using comparison or logical operators. create two variables x and y assign them the values TRUE and FALSE respectively use is.logical to check data type use as.logical to coerce other data types to logical # create variables x and y x &lt;- TRUE y &lt;- FALSE # check data type class(x) ## [1] &quot;logical&quot; is.logical(y) ## [1] TRUE The outcome of comparison operators is always logical. In the below example, we compare two numbers to see the outcome. # create two numeric variables x &lt;- 3 y &lt;- 4 # compare x and y x &gt; y ## [1] FALSE x &lt; y ## [1] TRUE # store the result z &lt;- x &gt; y class(z) ## [1] &quot;logical&quot; TRUE is represented by all numbers except 0. FALSE is represented only by 0 and no other numbers. # TRUE and FALSE are represented by 1 and 0 as.logical(1) ## [1] TRUE as.logical(0) ## [1] FALSE # using numbers as.numeric(TRUE) ## [1] 1 as.numeric(FALSE) ## [1] 0 # using different numbers as.logical(-2, -1.5, -1, 0, 1, 2) ## [1] TRUE Use as.logical() to coerce other data types to logical. # create variable of different data types age &lt;- as.integer(30) # integer score &lt;- 9.8 # numeric/double opt_course &lt;- TRUE # logical today &lt;- Sys.time() # date time as.logical(age) ## [1] TRUE as.logical(score) ## [1] TRUE as.logical(opt_course) ## [1] TRUE as.logical(today) ## [1] TRUE "],
["help.html", "Chapter 5 Getting Help in R 5.1 Introduction 5.2 Online Resources 5.3 Internal 5.4 Package Documentation", " Chapter 5 Getting Help in R 5.1 Introduction In this chapter, we will learn about the different methods of getting help in R. Often we get stuck while doing some analysis as either we do not know the correct function to use or its syntax. It is important for anyone who is new to R to know the right place to look for help. There are two ways to look for help in R: built in help system online In the first section, we will look at various ways to access the built in help system of R. In the second section, we will look at various online resources that can supplement the built in help system. Let us get started! 5.2 Online Resources 5.2.1 R Bloggers R Bloggers aggregates blogs written in english from across the globe. This is the first place you want to visit if you want help with R, data analysis, visualization and machine learning. There are blogs on a wide range of topics and the latest content is delivered to your inbox if you subscribe. If you are a blogger yourself, share it with th R community by adding your blog to R Bloggers. 5.2.2 Stack Overflow Stack Overflow is a great place to visit if you are having trouble with R code or packages. Chances are high that someone has already encountered the same or similar problem and you can use the answers given by R experts. In case you have encountered a new problem or issue, you can ask for help by providing a reproducible example of your analysis along with the R code. Use the reprex package to create reproducible examples. 5.2.3 Twitter The R community is very active on Twitter and there are lot of R experts who are willing to help those who are new to R. Use the hashtag #rstats if you are asking for help or guidance on Twitter. 5.2.4 RStudio Community RStudio Community is similar to Stack Overflow. You can ask questions related to RStudio, Shiny and tidyverse. 5.2.5 RStudio RStudio has very good resources including cheatsheets, webinars and blogs. 5.2.6 Reddit Reddit is another place where you can look for help. The discussions are moderated by R experts. There are subreddits for Rstats, Rlanguage, Rstudio and Rshiny. 5.2.7 R Weekly Visit RWeekly to get regular updates about the R community. You can find information about new packages, blogs, conferences, workshops, tutorials and R jobs. 5.2.8 R User Groups There are several R User Groups active across the globe. You can find the list here. Join the local user group to meet, discuss and learn from other R enthusiasts and experts. 5.2.9 Data Helpers Data Helpers is a list of data analysts, scientists and engineers willing to offer guidance put together by Angela Bassa. Visit the website to learn more about how you can approach for help and guidance. 5.3 Internal In this section, we will look at the following functions: help.start() help() ? ?? help.search() demo() example() library() vignette() browseVignettes() 5.3.1 help.start The help.start() function opens the documetation page in your browser. Here you can find manuals, reference and other materials. help.start() ## starting httpd help server ... done ## If nothing happens, you should open ## &#39;http://127.0.0.1:25521/doc/html/index.html&#39; yourself 5.3.2 help Use help() to access the documentation of functions and data sets. ? is a shortcut for help() and returns the same information. help(plot) ?plot 5.3.3 help.search help.search() will search all sources of documentation and return those that match the search string. ?? is a shortcut for help.search() and returns the same information. help.search(&#39;regression&#39;) ??regression 5.3.4 demo demo displays an interactive demonstration of certain topics provided in a R package. Typing demo() in the console will list the demos available in all the R packages installed. demo() demo(scoping) ## ## ## demo(scoping) ## ---- ~~~~~~~ ## ## &gt; ## Here is a little example which shows a fundamental difference between ## &gt; ## R and S. It is a little example from Abelson and Sussman which models ## &gt; ## the way in which bank accounts work. It shows how R functions can ## &gt; ## encapsulate state information. ## &gt; ## ## &gt; ## When invoked, &quot;open.account&quot; defines and returns three functions ## &gt; ## in a list. Because the variable &quot;total&quot; exists in the environment ## &gt; ## where these functions are defined they have access to its value. ## &gt; ## This is even true when &quot;open.account&quot; has returned. The only way ## &gt; ## to access the value of &quot;total&quot; is through the accessor functions ## &gt; ## withdraw, deposit and balance. Separate accounts maintain their ## &gt; ## own balances. ## &gt; ## ## &gt; ## This is a very nifty way of creating &quot;closures&quot; and a little thought ## &gt; ## will show you that there are many ways of using this in statistics. ## &gt; ## &gt; # Copyright (C) 1997-8 The R Core Team ## &gt; ## &gt; open.account &lt;- function(total) { ## + ## + list( ## + deposit = function(amount) { ## + if(amount &lt;= 0) ## + stop(&quot;Deposits must be positive!\\n&quot;) ## + total &lt;&lt;- total + amount ## + cat(amount,&quot;deposited. Your balance is&quot;, total, &quot;\\n\\n&quot;) ## + }, ## + withdraw = function(amount) { ## + if(amount &gt; total) ## + stop(&quot;You don&#39;t have that much money!\\n&quot;) ## + total &lt;&lt;- total - amount ## + cat(amount,&quot;withdrawn. Your balance is&quot;, total, &quot;\\n\\n&quot;) ## + }, ## + balance = function() { ## + cat(&quot;Your balance is&quot;, total, &quot;\\n\\n&quot;) ## + } ## + ) ## + } ## ## &gt; ross &lt;- open.account(100) ## ## &gt; robert &lt;- open.account(200) ## ## &gt; ross$withdraw(30) ## 30 withdrawn. Your balance is 70 ## ## ## &gt; ross$balance() ## Your balance is 70 ## ## ## &gt; robert$balance() ## Your balance is 200 ## ## ## &gt; ross$deposit(50) ## 50 deposited. Your balance is 120 ## ## ## &gt; ross$balance() ## Your balance is 120 ## ## ## &gt; try(ross$withdraw(500)) # no way.. 5.3.5 example example() displays examples of the specified topic if available. example(&#39;mean&#39;) ## ## mean&gt; x &lt;- c(0:10, 50) ## ## mean&gt; xm &lt;- mean(x) ## ## mean&gt; c(xm, mean(x, trim = 0.10)) ## [1] 8.75 5.50 5.4 Package Documentation 5.4.1 library Access the documentation of a package using help() inside library(). The package need not be installed for accessing the documentation. library(help = &#39;ggplot2&#39;) 5.4.2 vignette A vignette is a long form guide to a R package. You can access the vignettes available using vignette(). It will display alist of vignettes available in installed packages. vignette() To access a specific vignette from a package, specify the name of the vignette and the package. vignette(&#39;dplyr&#39;, package = &#39;dplyr&#39;) 5.4.3 browseVignettes browseVignettes() is another way to access the vignettes in installed packages. It will list the vignettes in each package along with links to the web page and R code. browseVignettes() 5.4.4 RsiteSearch RsiteSearch() will search for a specified topics in help pages, vignettes and task views using the search engine at this link and return the result in a browser. RSiteSearch(&#39;glm&#39;) ## A search query has been submitted to http://search.r-project.org ## The results page should open in your browser shortly "],
["vectors.html", "Chapter 6 Vectors 6.1 Introduction 6.2 Numeric Vector 6.3 Integer Vector 6.4 Character Vector 6.5 Logical Vector 6.6 Naming Vector Elements 6.7 Vector Coercion 6.8 Vector Operations 6.9 Missing Data 6.10 Index Vectors", " Chapter 6 Vectors 6.1 Introduction Vector is the most basic data structure in R. It is a sequence of elements of the same data type. If the elements are of different data types, they will be coerced to a common type that can accommodate all the elements. Vectors are generally created using c() (concatenate function), although depending on the data type of vector being created, other methods can be used. 6.2 Numeric Vector We will create a numeric vector using c() but you can use any function that creates a sequence of numbers. After that we will use is.vector() to check if it is a vector and class to check the data type. # create a numeric vector num_vect &lt;- c(1, 2, 3) # display the vector num_vect ## [1] 1 2 3 # check if it is a vector is.vector(num_vect) ## [1] TRUE # check data type class(num_vect) ## [1] &quot;numeric&quot; Let us look at other ways to create a sequence of numbers. We leave it as an exercise to the reader to understand the functions using help. # using colon vect1 &lt;- 1:10 vect1 ## [1] 1 2 3 4 5 6 7 8 9 10 # using rep vect2 &lt;- rep(1, 5) vect2 ## [1] 1 1 1 1 1 # using seq vect3 &lt;- seq(10) vect3 ## [1] 1 2 3 4 5 6 7 8 9 10 6.3 Integer Vector Creating an integer vector is similar to numeric vector except that we need to instruct R to treat the data as integer and not numeric or double. We will use the same methods we used for creating numeric vectors. To specify that the data is of type integer, we suffix the number with L. # integer vector int_vect &lt;- c(1L, 2L, 3L) int_vect ## [1] 1 2 3 # check data type class(int_vect) ## [1] &quot;integer&quot; # using colon vect1 &lt;- 1L:10L vect1 ## [1] 1 2 3 4 5 6 7 8 9 10 # using rep vect2 &lt;- rep(1L, 5) vect2 ## [1] 1 1 1 1 1 # using seq vect3 &lt;- seq(10L) vect3 ## [1] 1 2 3 4 5 6 7 8 9 10 6.4 Character Vector A character vector may contain a single character, a word or a group of words. The elements must be enclosed in single or double quotations. # character vector greetings &lt;- c(&quot;hello&quot;, &quot;good morning&quot;) greetings ## [1] &quot;hello&quot; &quot;good morning&quot; # check data type class(greetings) ## [1] &quot;character&quot; 6.5 Logical Vector A vector of logical values will either contain TRUE or FALSE or both. # logical vector vect_logic &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE) vect_logic ## [1] TRUE FALSE TRUE TRUE FALSE # check data type class(vect_logic) ## [1] &quot;logical&quot; In fact, you can create an integer vector and coerce it to type logical. # integer vector int_vect &lt;- rep(0L:1L, 3) int_vect ## [1] 0 1 0 1 0 1 # coerce to logical vector log_vect &lt;- as.logical(int_vect) log_vect ## [1] FALSE TRUE FALSE TRUE FALSE TRUE # check data type class(log_vect) ## [1] &quot;logical&quot; 6.6 Naming Vector Elements It is possible to name the different elements of a vector. The advantage of naming vector elements is that we can later on use these names to access the elements. Use names() to specify the names of a vector. You can specify the names while creating the vector or add them later. 6.6.1 Method 1: Create vector and add names later # create vector and add names later vect1 &lt;- c(1, 2, 3) # name the elements of the vector names(vect1) &lt;- c(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) # call vect1 vect1 ## One Two Three ## 1 2 3 6.6.2 Method 2: Specify names while creating vector # specify names while creating vector vect2 &lt;- c(John = 1, Jack = 2, Jill = 3, Jovial = 4) # call vect2 vect2 ## John Jack Jill Jovial ## 1 2 3 4 6.7 Vector Coercion Vectors are homogeneous i.e. all the elements of the vector must be of the same type. If we try to create a vector by combining different data types, the elements will be coerced to the most flexible type. The below table shows the order in which coercion occurs. character data type is the most flexible while logical data type is the least flexible. If you try to combine any other data type with character, all the elements will be coerced to type character. In the absence of character data, all elements will be coerced to numeric. Finally, if the data does not include character or numeric types, all the elements will be coerced to integer type. 6.7.1 Case 1: Different Data Types # vector of different data types vect1 &lt;- c(1, 1L, &#39;one&#39;, TRUE) # call vect1 vect1 ## [1] &quot;1&quot; &quot;1&quot; &quot;one&quot; &quot;TRUE&quot; # check data type class(vect1) ## [1] &quot;character&quot; 6.7.2 Case 2: Numeric, Integer and Logical # vector of different data types vect1 &lt;- c(1, 1L, TRUE) # call vect1 vect1 ## [1] 1 1 1 # check data type class(vect1) ## [1] &quot;numeric&quot; 6.7.3 Case : Integer and Logical # vector of different data types vect1 &lt;- c(1L, TRUE) # call vect1 vect1 ## [1] 1 1 # check data type class(vect1) ## [1] &quot;integer&quot; To summarize, below is the order in which coercion takes place: 6.8 Vector Operations In this section, we look at simple operations that can be performed on vectors in R. Remember that the nature of the operations depends upon the type of data. Below are a few examples: 6.8.1 Case 1: Vectors of same length # create two vectors vect1 &lt;- c(1, 3, 8, 4) vect2 &lt;- c(2, 7, 1, 9) # addition vect1 + vect2 ## [1] 3 10 9 13 # subtraction vect1 - vect2 ## [1] -1 -4 7 -5 # multiplication vect1 * vect2 ## [1] 2 21 8 36 # division vect1 / vect2 ## [1] 0.5000000 0.4285714 8.0000000 0.4444444 6.8.2 Case 2: Vectors of different length In the previous case, the length i.e. the number of elements in the vectors were same. What happens if the length of the vectors are unequal? In such cases, the shorter vector is recycled to match the length of the longer vector. The below example should clear this concept: # create two vectors vect1 &lt;- c(2, 7) vect2 &lt;- c(1, 8, 5, 2) # addition vect1 + vect2 ## [1] 3 15 7 9 # subtraction vect1 - vect2 ## [1] 1 -1 -3 5 # multiplication vect1 * vect2 ## [1] 2 56 10 14 # division vect1 / vect2 ## [1] 2.000 0.875 0.400 3.500 6.9 Missing Data Missing data is a reality. No matter how careful you are in collecting data for your analysis, chances are always high that you end up with some missing data. In R missing values are represented by NA. In this section, we will focus on the following: test for missing data remove missing data exclude missing data from analysis 6.9.1 Detect missing data We first create a vector with missing values. After that, we will use is.na() to test whether the data contains missing values. is.na() returns a logical vector equal to the length of the vector being tested. Another function that can be used for detecting missing values is complete.cases(). Below is an example: # vector with missing values vect1 &lt;- c(1, 3, NA, 5, 2) # use is.na is.na(vect1) ## [1] FALSE FALSE TRUE FALSE FALSE # use complete.cases complete.cases(vect1) ## [1] TRUE TRUE FALSE TRUE TRUE 6.9.2 Omit missing data In the presensce of missing data, all computations in R will return NA. To avoid this, we might want to remove the missing data before doing any computation. na.omit() will remove all missing values from the data. Let us look at an example: # vector with missing values vect1 &lt;- c(1, 3, NA, 5, 2) # call vect1 vect1 ## [1] 1 3 NA 5 2 # omit missing values na.omit(vect1) ## [1] 1 3 5 2 ## attr(,&quot;na.action&quot;) ## [1] 3 ## attr(,&quot;class&quot;) ## [1] &quot;omit&quot; 6.9.3 Exclude missing data To exclude missing values from computations, use na.rm and set it to TRUE. # vector with missing values vect1 &lt;- c(1, 3, NA, 5, 2) # compute mean mean(vect1) ## [1] NA # compute mean by excluding missing value mean(vect1, na.rm = TRUE) ## [1] 2.75 6.10 Index Vectors One of the most important steps in data analysis is selecting a subset of data from a bigger data set. Indexing helps in retrieving values individually or a set of values that meet a specific criteria. In this post, we look at various ways of indexing/subsetting vectors. [] is the index operator in R. We can use various expressions within [] to subset data. In R, index positions begin at 1 and not 0. To begin with, let us look at values in different index positions: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 5 10 9 2 3 6 7 8 4 1 # return third element vect1[3] ## [1] 9 # return seventh element vect1[7] ## [1] 7 6.10.1 Out of range index # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 9 3 6 5 7 1 8 10 2 4 # return value at index 0 vect1[0] ## integer(0) # length of the vector length(vect1) ## [1] 10 # out of range index vect1[11] ## [1] NA In the first case, we specified the index as 0 and in the second case we used the index 11, which is greater than the length of the vector. R returns an empty vector in the first case and NA in the second case. 6.10.2 Negative Index Using a negative index will delete the value in the said index position. Unlike other languages, it will not index elements from the end of the vector counting backwards. Let us look at an example to understand how negative index works in R: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 8 5 4 1 9 10 2 6 3 7 # drop third element vect1[-3] ## [1] 8 5 1 9 10 2 6 3 7 # drop seventh element vect1[-7] ## [1] 8 5 4 1 9 10 6 3 7 6.10.3 Subset Multiple Elements If we do not specify anything within [], all the elements in the vector will be returned. We can specify the index elements using any expression that generates a sequence of integers. Let us look at a few examples: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 4 6 5 3 1 8 7 2 10 9 # return all elements vect1[] ## [1] 4 6 5 3 1 8 7 2 10 9 # return first 5 values vect1[1:5] ## [1] 4 6 5 3 1 # return all values from the 5th position end &lt;- length(vect1) vect1[5:end] ## [1] 1 8 7 2 10 9 If you are using the colon to generate the index positions, you will have to specify both the starting and ending position, else, R will return an error. What if we want elements that are not in a sequence as we saw in the last example? In such cases, we have to create a vector using c() and use it to extract elements from the original vector. Below is an example: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 1 4 2 5 8 10 9 7 3 6 # extract 2nd, 5th and 7th element select &lt;- c(2, 5, 7) vect1[select] ## [1] 4 8 9 # extract elements in position 1 to 4, 6 and 9 select &lt;- c(1:4, 6, 9) vect1[select] ## [1] 1 4 2 5 10 3 6.10.4 Subset Named Vectors Vectors can be subset using the name of the elements. When using name of elements for subsetting, ensure that the names are enclosed in single or double quotations, else R will return an error. Let us look at a few examples: vect1 &lt;- c(score1 = 8, score2 = 6, score3 = 9) vect1 ## score1 score2 score3 ## 8 6 9 # extract score2 vect1[&#39;score2&#39;] ## score2 ## 6 # extract score1 and score3 vect1[c(&#39;score1&#39;, &#39;score3&#39;)] ## score1 score3 ## 8 9 6.10.5 Subset using logical values Logical values can be used to subset vectors. They are not very flexible but can be used for simple indexing. In all of the below examples, the logical vectors are recycled to match the length of the vector from which we subset data: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 6 9 3 8 7 10 2 4 5 1 # returns all values vect1[TRUE] ## [1] 6 9 3 8 7 10 2 4 5 1 # empty vector vect1[FALSE] ## integer(0) # values in odd positions vect1[c(TRUE, FALSE)] ## [1] 6 3 7 2 5 # values in even positions vect1[c(FALSE, TRUE)] ## [1] 9 8 10 4 1 6.10.6 Subset using logical expressions Logical expressions can be used to extract elements that meet specific criteria. This method is most flexible and useful as we can combine multiple conditions using relational and logical operators. Before we use logical expressions, let us spend some time understanding comparison and logical operators as we will be using them extensively hereafter. 6.10.6.1 Comparison Operators When you create an expression using a comparison operator, the output is always a logical value i.e. TRUE or FALSE. Let us see how we can use comparison operators to subset data: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 9 7 5 2 4 6 3 10 1 8 # return elements greater than 5 vect1 &gt; 5 ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE vect1[vect1 &gt; 5] ## [1] 9 7 6 10 8 # return elements greater than or equal to 5 vect1 &gt;= 5 ## [1] TRUE TRUE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE vect1[vect1 &gt;= 5] ## [1] 9 7 5 6 10 8 # return elements lesser than 5 vect1 &lt; 5 ## [1] FALSE FALSE FALSE TRUE TRUE FALSE TRUE FALSE TRUE FALSE vect1[vect1 &lt; 5] ## [1] 2 4 3 1 # return elements lesser than or equal to 5 vect1 &lt;= 5 ## [1] FALSE FALSE TRUE TRUE TRUE FALSE TRUE FALSE TRUE FALSE vect1[vect1 &lt;= 5] ## [1] 5 2 4 3 1 # return elements equal to 5 vect1 == 5 ## [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE vect1[vect1 == 5] ## [1] 5 # return elements not equal to 5 vect1 != 5 ## [1] TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE vect1[vect1 != 5] ## [1] 9 7 2 4 6 3 10 1 8 6.10.7 Logical Operators Let us combine comparison and logical operators to create expressions and use them to subset vectors: # random sample of 10 values vect1 &lt;- sample(10) vect1 ## [1] 6 3 1 10 2 4 9 5 8 7 # return all elements less than 8 or divisible by 3 vect1[(vect1 &lt; 8 | (vect1 %% 3 == 0))] ## [1] 6 3 1 2 4 9 5 7 # return all elements less than 7 or divisible by 2 vect1[(vect1 &lt; 7 | (vect1 %% 2 == 0))] ## [1] 6 3 1 10 2 4 5 8 "],
["dataframes.html", "Chapter 7 Dataframes 7.1 Introduction 7.2 Create dataframes 7.3 Basic Information 7.4 Select Columns 7.5 Select Rows", " Chapter 7 Dataframes 7.1 Introduction In this chapter, we will learn to: create dataframe select columns select rows utitlity functions 7.2 Create dataframes Use data.frame to create dataframes. Below is the function syntax: args(data.frame) ## function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, ## fix.empty.names = TRUE, stringsAsFactors = default.stringsAsFactors()) ## NULL Data frames are basically lists with elements of equal lenght and as such, they are heterogeneous. Let us create a dataframe: name &lt;- c(&#39;John&#39;, &#39;Jack&#39;, &#39;Jill&#39;) age &lt;- c(29, 25, 27) graduate &lt;- c(TRUE, TRUE, FALSE) students &lt;- data.frame(name, age, graduate) students ## name age graduate ## 1 John 29 TRUE ## 2 Jack 25 TRUE ## 3 Jill 27 FALSE 7.3 Basic Information class(students) ## [1] &quot;data.frame&quot; names(students) ## [1] &quot;name&quot; &quot;age&quot; &quot;graduate&quot; colnames(students) ## [1] &quot;name&quot; &quot;age&quot; &quot;graduate&quot; str(students) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ name : Factor w/ 3 levels &quot;Jack&quot;,&quot;Jill&quot;,..: 3 1 2 ## $ age : num 29 25 27 ## $ graduate: logi TRUE TRUE FALSE dim(students) ## [1] 3 3 nrow(students) ## [1] 3 ncol(students) ## [1] 3 7.4 Select Columns 7.4.1 Single Column [] [[]] $ # using [ students[1] ## name ## 1 John ## 2 Jack ## 3 Jill # using [[ students[[1]] ## [1] John Jack Jill ## Levels: Jack Jill John # using $ students$name ## [1] John Jack Jill ## Levels: Jack Jill John 7.4.2 Multiple Columns students[, 1:3] ## name age graduate ## 1 John 29 TRUE ## 2 Jack 25 TRUE ## 3 Jill 27 FALSE students[, c(1, 3)] ## name graduate ## 1 John TRUE ## 2 Jack TRUE ## 3 Jill FALSE 7.5 Select Rows # single row students[1, ] ## name age graduate ## 1 John 29 TRUE # multiple row students[c(1, 3), ] ## name age graduate ## 1 John 29 TRUE ## 3 Jill 27 FALSE If you have observed carefully, the column names has been coerced to type factor. This happens because of a default argument in data.frame which is stringsAsFactors which is set to TRUE. If you do not want to treat it as factors, set the argument to FALSE. students &lt;- data.frame(name, age, graduate, stringsAsFactors = FALSE) "],
["factors.html", "Chapter 8 Factors 8.1 Introduction 8.2 Create Factors", " Chapter 8 Factors 8.1 Introduction In this chapter, we will learn to: create factors order levels specify labels check levels number of levels Categorical or qualitative data in R is treated as data type factor. 8.2 Create Factors args(factor) ## function (x = character(), levels, labels = levels, exclude = NA, ## ordered = is.ordered(x), nmax = NA) ## NULL devices &lt;- factor(c(&#39;Mobile&#39;, &#39;Tablet&#39;, &#39;Desktop&#39;)) devices ## [1] Mobile Tablet Desktop ## Levels: Desktop Mobile Tablet # number of levels nlevels(devices) ## [1] 3 # levels levels(devices) ## [1] &quot;Desktop&quot; &quot;Mobile&quot; &quot;Tablet&quot; "],
["lists.html", "Chapter 9 Lists 9.1 Introduction 9.2 Creating Lists 9.3 Access List Elements 9.4 Coerce other objects 9.5 Coerce list to other objects", " Chapter 9 Lists 9.1 Introduction Lists are very useful as they are heterogeneous i.e. they can contain different data types. If you remember, vectors and matrices are homogeneous i.e. they can contain only one type of data. If you include different data types, they will all be coerced to the same type. With lists, it is different. In this chapter, we will delve deeper into lists. how to create lists access list elements name list elements coerce other R objects to list coerce list to other R objects 9.2 Creating Lists To create a list, we use the list() function. Let us create a simple list to demonstrate how they can contain different data types. # numeric vector vect1 &lt;- 1:10 # character vector vect2 &lt;- c(&#39;Jack&#39;, &#39;John&#39;, &#39;Jill&#39;) # logical vector vect3 &lt;- c(TRUE, FALSE) # matrix mat &lt;- matrix(data = 1:9, nrow = 3) # list l &lt;- list(vect1, vect2, vect3, mat) l ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;Jack&quot; &quot;John&quot; &quot;Jill&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## [[4]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 If you observe the output, all the elements of the list retain their data types. Now let us learn how to access the elements of the list. 9.3 Access List Elements You can access the elements of a list using the following operators: [[ [ $ Let us try them one by one. # using [[ l[[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 # using [ l[1] ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 [[ returns a vector while [ returns a list. The $ operator can be used only when we have named elements in the list. Let us add names to the elements. Use the names() function to add names to the list. # named elements names(l) &lt;- c(&#39;vect1&#39;, &#39;vect2&#39;, &#39;vect3&#39;, &#39;mat&#39;) l ## $vect1 ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $vect2 ## [1] &quot;Jack&quot; &quot;John&quot; &quot;Jill&quot; ## ## $vect3 ## [1] TRUE FALSE ## ## $mat ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # use $ l$vect1 ## [1] 1 2 3 4 5 6 7 8 9 10 # use [[ l[[&#39;vect1&#39;]] ## [1] 1 2 3 4 5 6 7 8 9 10 # use [ l[&#39;vect1&#39;] ## $vect1 ## [1] 1 2 3 4 5 6 7 8 9 10 9.4 Coerce other objects You can coerce other objects to list using as.list(). # vector vect1 &lt;- 1:10 as.list(vect1) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 ## ## [[9]] ## [1] 9 ## ## [[10]] ## [1] 10 # matrix mat &lt;- matrix(data = 1:9, nrow = 3) as.list(mat) ## [[1]] ## [1] 1 ## ## [[2]] ## [1] 2 ## ## [[3]] ## [1] 3 ## ## [[4]] ## [1] 4 ## ## [[5]] ## [1] 5 ## ## [[6]] ## [1] 6 ## ## [[7]] ## [1] 7 ## ## [[8]] ## [1] 8 ## ## [[9]] ## [1] 9 9.5 Coerce list to other objects Use unlist() to coerce a list to vector. # unlist unlist(l) ## vect11 vect12 vect13 vect14 vect15 vect16 vect17 vect18 vect19 ## &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; ## vect110 vect21 vect22 vect23 vect31 vect32 mat1 mat2 mat3 ## &quot;10&quot; &quot;Jack&quot; &quot;John&quot; &quot;Jill&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; ## mat4 mat5 mat6 mat7 mat8 mat9 ## &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; # remove names unlist(l, use.names = FALSE) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; ## [9] &quot;9&quot; &quot;10&quot; &quot;Jack&quot; &quot;John&quot; &quot;Jill&quot; &quot;TRUE&quot; &quot;FALSE&quot; &quot;1&quot; ## [17] &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; "],
["packages.html", "Chapter 10 R Packages 10.1 Introduction 10.2 Install Packages 10.3 Install Different Versions 10.4 Installed Packages 10.5 Library Paths", " Chapter 10 R Packages 10.1 Introduction In this chapter, we will learn about R packages. Packages are fundamental to R. There are approximately 15000 packages available on CRAN or the Comprehensive R Archive Network. Packages are available for different topics. You should always look for a package before writing code from scratch. In case you have written your own codes for a new analysis or topic, do share it with the R community by converting the code into a package. You can learn more about building R packages from R Packages, a book written by Hadley Wickham. In this post, we will learn to: install R packages from CRAN GitHub BitBucket Bioconductor rForge install different versions of a package load, update &amp; remove installed packages access package documentation 10.2 Install Packages 10.2.1 CRAN Packages from CRAN can be installed using install.packages(). The name of the package must be enclosed in single or double quotes. install.packages(&#39;ggplot2&#39;) 10.2.2 GitHub Some R packages are made available on GitHub before releasing them on CRAN. Such packages can be installed using install_github() from devtools or remotes package. You need tp specify the name of the repository and the package. For example, to download ggplot2 or dplyr, below is the code: devtools::install_github(&quot;tidyverse/ggplot2&quot;) remotes::install_github(&quot;tidyverse/dplyr&quot;) 10.2.3 BitBucket Bitbucket is similar to GitHub. You can install packages from Bitbucket using install_bitbucket() from devtools or remotes pacakge. devtools::install_bitbucket(&quot;dannavarro/lsr-package&quot;) remotes::install_bitbucket(&quot;dannavarro/lsr-package&quot;) 10.2.4 Bioconductor Bioconductor provides tools for analysis and comprehension of high throughput genomic data. Packages hosted on Bioconductor can be installed in multiple ways: 10.2.4.1 devtools Use install_bioc() from devtools. install_bioc(&quot;SummarizedExperiment&quot;) 10.2.4.2 biocLite Use biocLite() function. source(&#39;http://bioconductor.org/biocLite.R&#39;) biocLite(&#39;GenomicFeatures&#39;) 10.2.5 rForge Many R packages are hosted at R-Forge, a platform for development of R packages. install.packages(&#39;quantstrat&#39;, repos = &#39;https://r-forge.r-project.org/&#39;) 10.3 Install Different Versions Now that we have learnt how to install packages, let us look at installing different versions of the same package. remotes::install_version(&#39;dplyr&#39;, version = 0.5.0) If you want to install the latest release from GitHub, append @*release to the repository name. For example, to install the latest release of dplyr: remotes::install_github(&#39;tidyverse/dplyr@*release&#39;) 10.4 Installed Packages installed.packages(): view currently installed packages library('package_name'): load packages autoload('function_name', 'package_name'): load functions and data from packages only when called in the script available.package(): packages available for installation old.packages(): packages which have new versions available new.packages(): packages already not installed update.packages(): update packages which have new versions remove.packages('package_name'): remove installed packages 10.5 Library Paths Library is a directory that contains all installed packages. Usually there will be more than one R library in your systme. You can find the location of the libraries using .libPaths(). .libPaths() ## [1] &quot;C:/Users/HP/Documents/R/win-library&quot; ## [2] &quot;C:/Program Files/R/R-3.5.1/library&quot; You can use lib.loc when you want to install, load, update and remove packages from a particular library. 10.5.1 Install install.packages(&#39;stringr&#39;, lib.loc = &quot;C:/Program Files/R/R-3.4.1/library&quot;) 10.5.2 Load library(lubridate, lib.loc = &quot;C:/Program Files/R/R-3.4.1/library&quot;) 10.5.3 Update Packages update.packages(lib.loc = &quot;C:/Program Files/R/R-3.4.1/library&quot;) 10.5.4 Remove Packages remove.packages(lib.loc = &quot;C:/Program Files/R/R-3.4.1/library&quot;) "],
["references.html", "References", " References "]
]
